package matthewm101;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import javax.swing.JProgressBar;
import javax.swing.SwingWorker;

/**
 * A class that stores the parsed data from an OpenStreetMap xml file and uses
 * the data to produce a heatmap.
 * @author Matthew M
 */
public class HeatmapGenerator {

    /**
     * A list containing every point of interest parsed from the XML file.
     */
    private List<PointOfInterest> poiList;

    /**
     * A map of lists that contain all points of interest that possess a tag
     * that has a specific key.
     * For example, poiTagMap.get("name") will return all points of interest
     * with a defined name.
     */
    private Map<String, List<PointOfInterest>> poiTagMap;

    /**
     * A map of sets that contain all values that are bound to certain keys
     * within the tags of all the points of interest.
     * For example, valueTagMap.get("name") will return the names of all
     * points of interest.
     */
    private Map<String, Set<String>> valueTagMap;

    /**
     * A list of criteria, given as key-value pairs. When a heatmap is
     * generated, each point of interest represented in the heatmap must
     * meet at least one of these criteria.
     */
    private List<Entry<String, String>> criteriaList = new ArrayList<>();

    /**
     * The background image for the heatmap.
     */
    private BufferedImage backgroundImage;

    /**
     * The location of the XML file that contains the map data.
     */
    private File xmlLocation;

    /**
     * The minimum latitude of the map data's bounds.
     */
    private double minLat;
    /**
     * The maximum latitude of the map data's bounds.
     */
    private double maxLat;
    /**
     * The minimum longitude of the map data's bounds.
     */
    private double minLon;
    /**
     * The maximum longitude of the map data's bounds.
     */
    private double maxLon;

    /**
     * The translucent heatmap image that is generated by this class.
     */
    private BufferedImage heatmapImage;

    /**
     * A reference to a menu's progress bar, which will be updated as certain
     * lengthy tasks run.
     */
    private JProgressBar progressBar;

    /**
     * A reference to a menu that will need to be notified when a setup task
     * (AKA parsing the XML file) is complete.
     */
    private HeatmapSetupHandler setupHandler;

    /**
     * A reference to a menu that will need to be notified when a generate task
     * (AKA creating and painting the heatmap) is complete.
     */
    private HeatmapGeneratedHandler generatedHandler;

    /**
     * For each pixel in the heatmap's image, this returns the distance to the
     * closest point of interest that meets the given criteria.
     */
    private double[] distances;

    /**
     * For each pixel in the heatmap's image, this returns the reference to the
     * closest point of interest that meets the given criteria.
     */
    private PointOfInterest[] nearestPOIs;

    /**
     * The maximum distance that a pixel can be from a point of interest in
     * order to be painted by the heatmap. By default, this is 5km, stored as
     * degrees of latitude/longitude.
     */
    private double maxDistance = 5d / 111d;
    
    /**
     * Creates a new HeatmapGenerator object with the specified dimension,
     * progress bar reference, and event handler.
     * @param xml The xml file to be read.
     * @param bg The background image for the heatmap.
     * @param progress A reference to the progress bar.
     * @throws java.io.FileNotFoundException if file is not found
     */
    public HeatmapGenerator(File xml, BufferedImage bg, JProgressBar progress)
            throws FileNotFoundException {
        if (!xml.exists()) {
            throw new FileNotFoundException();
        }
        xmlLocation = xml;
        backgroundImage = bg;
        progressBar = progress;
    }

    /**
     * Returns the background image for this generator.
     * @return The background image
     */
    public BufferedImage getBackgroundImage() {
        return backgroundImage;
    }

    /**
     * Returns the heatmap image for this generator.
     * @return The heatmap image
     */
    public BufferedImage getHeatmapImage() {
        return heatmapImage;
    }
    
    /**
     * Adds a criterion that will be used to filter the POIS used to generate a
     * heatmap. The heatmap will represent the distance from a specific pixel to
     * the closest POI that fulfills at least one of the criteria.
     * @param key The key of the tag each POI must have. Cannot be null.
     * @param value The value that must be matched to a key. If this is null,
     * all POIs that have the key will be matched. If this is not null, all POIs
     * that have the key and have this value mapped to the key will be matched.
     */
    public void addCriterion(String key, String value) {
        criteriaList.add(new SimpleEntry<>(key, value));
    }
    
    /**
     * Removes all criteria from the criteria list. This is meant to be called
     * when the criteria are changed.
     */
    public void removeAllCriteria() {
        criteriaList.clear();
    }
    
    /**
     * Sets the JProgressBar reference that will be updated as the heatmap is
     * generated.
     * @param bar The bar to keep updated.
     */
    public void setProgressBarToUpdate(JProgressBar bar) {
        progressBar = bar;
    }
    
    /**
     * Given the coordinate of a pixel in the image, returns the latitude of
     * the center of the pixel.
     * Note: "in the center of the pixel" means that if the latitude bounds are
     * 0 and 1 and the image has a height of 100, getLatFromY(0) would return
     * 0.005.
     * @param y The y-coordinate of the pixel.
     * @return  The latitude represented by the pixel.
     */
    public double getLatFromY(int y) {
        double difference = maxLat - minLat;
        double ratio = (y + 0.5) / backgroundImage.getHeight();
        return minLat + difference * ratio;
    }
    
    /**
     * Given the coordinate of a pixel in the image, returns the longitude of
     * the center of the pixel.
     * Note: "in the center of the pixel" means that if the longitude bounds are
     * 0 and 1 and the image has a width of 100, getLonFromX(0) would return
     * 0.005.
     * @param x The x-coordinate of the pixel.
     * @return  The longitude represented by the pixel.
     */
    public double getLonFromX(int x) {
        double difference = maxLon - minLon;
        double ratio = (x + 0.5) / backgroundImage.getWidth();
        return minLon + difference * ratio;
    }

    /**
     * Returns a map that contains the list of points of interest that contain
     * a certain key.
     * @return The map
     */
    public Map<String, List<PointOfInterest>> getPOITagMap() {
        return poiTagMap;
    }

    /**
     * Returns a map that contains the set of values that are paired to a
     * certain key in at least one point of interest.
     * @return The map
     */
    public Map<String, Set<String>> getValueTagMap() {
        return valueTagMap;
    }
    
    /**
     * Sets the maximum distance that a pixel must be from a point of interest
     * to be colored in the heatmap. Note: the parameter for this function
     * should be in kilometers, as it will be converted to map degrees using
     * the conversion factor 111 km = 1 degree of latitude/longitude.
     * @param dist The maximum distance in kilometers.
     */
    public void setMaxDistance(double dist) {
        maxDistance = dist / 111D;
    }
    
    /**
     * Returns the nearest POI, based on a pair of coordinate from the
     * background image.
     * @param x The x coordinate
     * @param y The y coordinate
     * @return The POI that is closest to the given coordinates
     */
    public PointOfInterest getNearestPOI(int x, int y) {
        if (nearestPOIs == null) {
            return null;
        }
        return nearestPOIs[x + y * backgroundImage.getWidth()];
    }
    
    /**
     * Returns the distance to the nearest POI in kilometers, based on a pair
     * of coordinates from the background image.
     * @param x The x coordinate
     * @param y The y coordinate
     * @return The distance to the nearest POI, in kilometers
     */
    public double getDistanceToNearestPOI(int x, int y) {
        return distances[x + y * backgroundImage.getWidth()] * 111D;
    }

    /**
     * Returns a TaskGenerate that can be executed.
     * @param handler A class that will be notified when the task finishes.
     * @return The task.
     */
    public TaskGenerate getGenerateTask(HeatmapGeneratedHandler handler) {
        this.generatedHandler = handler;
        return new TaskGenerate();
    }

    /**
     * Returns a TaskRegenerate that can be executed.
     * @param handler A class that will be notified when the task finishes.
     * @return The task.
     */
    public TaskRegenerate getRegenerateTask(HeatmapGeneratedHandler handler) {
        this.generatedHandler = handler;
        return new TaskRegenerate();
    }

    /**
     * Returns a TaskSetup that can be executed.
     * @param handler A class that will be notified when the task finishes.
     * @return The task.
     */
    public TaskSetup getSetupTask(HeatmapSetupHandler handler) {
        this.setupHandler = handler;
        return new TaskSetup();
    }
    
    /**
     * An implementation of the distance formula; returns the distance from
     * (x1,y1) to (x2,y2).
     * @param x1 x-coordinate of first point
     * @param y1 y-coordinate of first point
     * @param x2 x-coordinate of second point
     * @param y2 y-coordinate of second point
     * @return the distance between the two points
     */
    public static double dist(double x1, double y1, double x2, double y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    /**
     * Defines that a class can respond to TaskSetup finishing.
     */
    public interface HeatmapSetupHandler {

        /**
         * Called when a TaskSetup finishes setting up a HeatmapGenerator.
         */
        void handleSetup();
    }

    /**
     * Defines that a class can respond to TaskGenerate or TaskRegenerate.
     */
    public interface HeatmapGeneratedHandler {

        /**
         * Called when a TaskGenerate or TaskRegenerate finishes generating
         * a heatmap.
         */
        void handleGenerated();
    }
    
    /**
     * A task that, when executed, will generate a heatmap. Outside of
     * performing its task, this class will do two things:
     * 1. It will notify an event listener when this task is complete.
     * 2. It will keep a JProgressBar updated.
     */
    public class TaskGenerate extends SwingWorker<Void, String> {
        @Override
        public Void doInBackground() throws Exception {
            generateHeatmap();
            generatedHandler.handleGenerated();
            return null;
        }
    
        /**
        * Sets the image to a heatmap that shows distance to certain POIs.
        * Before this is called, the HeatmapGenerator should have its POI list
        * properly filled via the setup() method, and it should have criteria
        * added via the addCriterion() method.
        */
        private void generateHeatmap() {
            //Step 1: using the criteria keys only, generate a shortlist of
            //potentially valid points of interest.
            //Sets are used to prevent duplicates.
            HashSet<String> usedKeys = new HashSet<>();
            for (Entry<String, String> ent : criteriaList) {
                usedKeys.add(ent.getKey());
            }
            HashSet<PointOfInterest> shortlist = new HashSet<>();
            for (String key : usedKeys) {
                if (poiTagMap.containsKey(key)) {
                    shortlist.addAll(poiTagMap.get(key));
                }
            }
            
            //Step 2: using all parts of the criteria, cut the list down to only
            //the points of interest that meet at least one of the criteria.
            List<PointOfInterest> filtered =
                    StreetMapDataInterpreter.filter(new ArrayList<>(shortlist),
                            criteriaList);
           
            //Step 3: for each pixel on the map, calculate the distance between
            //the pixel and the closest POI that meets >=1 of the criteria.
            int[] pixels = new int[backgroundImage.getHeight()
                    * backgroundImage.getWidth()];
            double[] minDistances = new double[backgroundImage.getHeight()
                    * backgroundImage.getWidth()];
            PointOfInterest[] closestPOIs =
                    new PointOfInterest[backgroundImage.getHeight()
                            * backgroundImage.getWidth()];
            for (int i = 0; !isCancelled() && i < pixels.length; i++) {
                if (i % (pixels.length / 100) == 0) {
                    publish("Calculating distances: "
                           + (i / (pixels.length / 100)) + "%");
                    setProgress(i / (pixels.length / 100));
                }
                minDistances[i] = 500;
                int x = i % backgroundImage.getWidth();
                int y = i / backgroundImage.getWidth();
                for (PointOfInterest poi : filtered) {
                    double d = dist(poi.getLongitude(), poi.getLatitude(),
                           getLonFromX(x), getLatFromY(y));
                    if (d < minDistances[i]) {
                        minDistances[i] = d;
                        closestPOIs[i] = poi;
                    }
                }
            }
            //Step 4: paint the heatmap using the distances.
            for (int i = 0; !isCancelled() && i < pixels.length; i++) {
                if (i % (pixels.length / 100) == 0) {
                    publish("Painting pixels: " + (i / (pixels.length / 100))
                           + "%");
                    setProgress(i / (pixels.length / 100));
                }
                float factor = (float) (minDistances[i] / maxDistance);
                if (factor <= 1) {
                    pixels[i] = Color.HSBtoRGB(0.8f * factor, 1, 1);
                    pixels[i] &= 0xffffff;
                    pixels[i] |= 0x70000000;
                }
            }
            if (!isCancelled()) {
                distances = minDistances;
                nearestPOIs = closestPOIs;
                heatmapImage = new BufferedImage(backgroundImage.getWidth(),
                        backgroundImage.getHeight(),
                        BufferedImage.TYPE_INT_ARGB);
                heatmapImage.setRGB(0, 0, heatmapImage.getWidth(),
                        heatmapImage.getHeight(), pixels, 0,
                        heatmapImage.getWidth());
            }
        }
        
        @Override
        public void process(List<String> updates) {
            if (!isCancelled() && updates.size() > 0) {
                progressBar.setString(updates.get(updates.size() - 1));
                progressBar.setValue(this.getProgress());
            }
        }
    }
    
    /**
     * A task that, when executed, will generate a heatmap. This is different
     * from Generate in that it will use the distances it had stored from the
     * last task, and only change the max distance represented in the heatmap.
     */
    public class TaskRegenerate extends SwingWorker<Void, String> {
        @Override
        public Void doInBackground() throws Exception {
            generateHeatmap();
            generatedHandler.handleGenerated();
            return null;
        }
    
        /**
        * Sets the image to a heatmap that shows distance to certain POIs.
        * Before this is called, the HeatmapGenerator should have its POI list
        * properly filled via the setup() method, and it should have criteria
        * added via the addCriterion() method.
        */
        private void generateHeatmap() {
            int[] pixels = new int[backgroundImage.getHeight()
                    * backgroundImage.getWidth()];
            for (int i = 0; !isCancelled() && i < pixels.length; i++) {
                if (i % (pixels.length / 100) == 0) {
                    publish("Painting pixels: " + (i / (pixels.length / 100))
                           + "%");
                    setProgress(i / (pixels.length / 100));
                }
                float factor = (float) (distances[i] / maxDistance);
                if (factor <= 1) {
                    pixels[i] = Color.HSBtoRGB(0.8f * factor, 1, 1);
                    pixels[i] &= 0xffffff;
                    pixels[i] |= 0x70000000;
                }
            }
            if (!isCancelled()) {
                heatmapImage = new BufferedImage(backgroundImage.getWidth(),
                        backgroundImage.getHeight(),
                        BufferedImage.TYPE_INT_ARGB);
                heatmapImage.setRGB(0, 0, heatmapImage.getWidth(),
                        heatmapImage.getHeight(), pixels, 0,
                        heatmapImage.getWidth());
            }
        }
        
        @Override
        public void process(List<String> updates) {
            if (!isCancelled() && updates.size() > 0) {
                progressBar.setString(updates.get(updates.size() - 1));
                progressBar.setValue(this.getProgress());
            }
        }
    }
       
    /**
     * A task that, when executed, will generate the POI list. Outside of
     * performing its task, this class will do two things:
     * 1. It will notify an event listener when this task is complete.
     * 2. It will keep a JProgressBar updated.
     */
    public class TaskSetup extends SwingWorker<Void, String> {
        
        @Override
        public Void doInBackground() throws Exception {
            setup();
            setupHandler.handleSetup();
            return null;
        }

        /**
         * Fills this HeatmapGenerator's PointOfInterest-storing data
         * structures.
         * @throws IOException If the file is not found.
         */
        public void setup() throws IOException {
            //Step 1: parse the XML file.
            PointOfInterestParser parser = new PointOfInterestParser();
            poiList = parser.parse(xmlLocation, this);
            progressBar.setIndeterminate(false);

            //Step 2: iterate through each of the points of interest and fill
            //both of the tag maps. This will help optimize the heatmap
            //generation by cutting down on the number of points of interest
            //that will need to be read.
            poiTagMap = new HashMap<>();
            valueTagMap = new HashMap<>();
            for (int i = 0; !isCancelled() && i < poiList.size(); i++) {
                if (i % (poiList.size() / 100) == 0) {
                    publish("Sorting points of interest: " + (i
                            / (poiList.size() / 100)) + "%");
                    setProgress(i / (poiList.size() / 100));
                }
                PointOfInterest poi = poiList.get(i);
                Set<String> keys = poi.getDescriptors().keySet();
                for (String k : keys) {
                    if (!poiTagMap.containsKey(k)) {
                        poiTagMap.put(k, new ArrayList<>());
                    }
                    if (!valueTagMap.containsKey(k)) {
                        valueTagMap.put(k, new HashSet<>());
                    }
                    poiTagMap.get(k).add(poi);
                    valueTagMap.get(k).add(poi.getDescriptors().get(k));
                }
            }
            double[] bounds = parser.getBounds();
            minLat = bounds[0];
            maxLat = bounds[1];
            minLon = bounds[2];
            maxLon = bounds[3];
        }
        
        @Override
        public void process(List<String> updates) {
            if (!isCancelled() && updates.size() > 0) {
                progressBar.setString(updates.get(updates.size() - 1));
                progressBar.setValue(this.getProgress());
            }
        }
    }
}
